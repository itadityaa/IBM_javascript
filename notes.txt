In JavaScript, variables are used to store and manage data. Variables act as containers for various types of information or values. You can think of a variable as a named storage location that holds data, and you can use this data in your JavaScript code.

To create a variable in JavaScript, you also need to declare it using one of three keywords, var, let, or const. The declaration tells JavaScript that you want to reserve a spot in memory to store data.

Var was the original way to declare variables in JavaScript, and it has function level scope. This means that a variable declared with var is available throughout the entire function in which it is declared.

Let was introduced in ES6 and provides block level scoping. This means, that a variable declared with let is only available within the block enclosed by curly braces in which it is defined. This scope is more predictable and less error prone.

Const is also introduced in ES6 and is used to declare variables with constant values. Once you assign a value to a const variable, you cannot reassign it a different value. It also has block level scoping. Const variables are often used for values that should not change, such as mathematical constants or references to immutable objects.

Variable names must start with a letter, underscore, or dollar sign, and can contain letters, numbers, underscores, and dollar signs. Variable names are case sensitive.

Variables declared with let can be reassigned, but not redeclared within the same block. 
Valid: 
{
  let a=9;
  a=12;
}

Invalid:
{
  let a=0;
  let a=12; // will give error
}

Variables declared with let can be reassigned, but not redeclared within the same block. 

JavaScript is a dynamically typed language, which means that you don't need to explicitly specify the data type of a variable when you declare it. The data type is determined dynamically at runtime based on the value you assign to the variable.

JavaScript has several built-in data types, which can be categorized into the following major categories. Primitive data types, composite data types.

Primitive:
Strings represents text. A string is enclosed in single or double quotes. Number represents both integers and floating-point numbers. Boolean represents true or false values. Undefined represents a variable that has been declared, but hasn't been assigned a value. Null represents an empty value or absence of any object value.

Composite: 
Composite data types are those that can hold and manage multiple values as a single unit. These data types are used to organize and manipulate collections of data.

Array and object are two composite data types. An array in JavaScript is a list like data structure for storing multiple value. While an object is a collection of key value pairs used for structured data storage. JavaScript's dynamic typing allows variables to change data types during execution.

Operators in JavaScript are special symbols or keywords used to perform operations on variables and values. JavaScript supports a variety of operators, including: arithmetic operators, comparison operators, logical operators, assignment operators, unary operators, and typeof operators.

Arithmetic operators are used for basic mathematical calculations. Common arithmetic operators include: addition, subtraction, multiplication, division, and modulus. 

Comparison operators are used to compare two values or variables and return a Boolean true or false result. Common comparison operators include: equality, inequality, strict equality, strict inequality, less than, greater than, less than or equal to, and greater than or equal to.

# Example
let a = 5;
let b = 6;

let isEqual = a == b; // equality
let isNotEqual = a != b; // inequality
let isStrictEqual = a === b; // strict equality
let isStrictNotEqual = a !==b; // strict inequality
let isGreaterThan = a > b; // greater than
let isLessThan = a < b; // less than
let isGreaterOrEqual = a >= b; // greater than or equality
let isLessOrEqual = a <= b; // less than or equality

Logical operators are used to combine or manipulate Boolean values. Common logical operators include logical AND, logical OR, and logical NOT.
&& - AND
|| - OR
! - NOT

Unary operators operate on a single value or variable. Common unary operators include increment and decrement.
let a = 5;
a++;
a--;

The typeof operator is a built-in operator in JavaScript that allows you to determine the data type of a variable or an expression. It returns a string representing the type of operand.

The possible return values for typeof are: "Undefined" if the variable is declared but not defined, "Object" for objects, arrays, and null, "Boolean" for Boolean values, "Number" for numbers, and "String" for strings.

let myVar = 42;
let myVarType = typeof myVar;

An expression is a combination of values, variables, and operators that can be evaluated to produce a single value.

Control flow refers to the order in which statements are executed in a JavaScript program. While conditional statements, often referred to as decision making statements, are used to manage this flow based on specified conditions. Some of the conditional statements in JavaScript are if statement, else if statement, else statement, nested if else statement, switch statement, and ternary operator.

let age = 25;
let name = "John";

if (age > 18) {
  console.log("You are an adult");
} else if (age < 18) {
  console.log("You are a minor");
} else {
  console.log("You are a teenager");
}

const temperture = 20;
const isRaining = true;

if (temperature > 18) {
  if (isRaining) {
    console.log("It's warm and raining");
  } else {
    console.log("It's warm and not raining");
  }
} else {
  console.log("It's cold");
}

The switch statement allows you to compare a value against multiple possible case values and execute code based on the first matching case.

let day = "Friday";
switch (day) {
  case "Monday":
    console.log("Today is Monday");
    break;
  case "Tuesday":
    console.log("Today is Tuesday");
    break;
  case "Wednesday":
    console.log("Today is Wednesday");
    break;
  default:
    console.log("Have a nice day");
}

The ternary operator is a concise way to write conditional statements such as if else condition.
let age = 25;
let canVote = age >= 18 ? 'yes' : 'no';

A for loop is a control structure in JavaScript that allows you to execute a block of code repeatedly for a specified number of times, or until a particular condition is met. It consists of three parts, initialization, condition, and update. Initialization, this part is where you initialize a loop control variable, typically with an initial value. Condition, this is a Boolean expression that is evaluated before each iteration. If the condition is true, the loop continues, otherwise it terminates. Update, this part is responsible for changing the loop control variable in each iteration, often incrementing or decrementing its value.

for (let i = 0; i < 10; i++) {
  console.log(i);
} - prints 0 to 9

A while loop is a control structure in JavaScript that allows you to execute a block of code repeatedly. As long as the specified condition is true, it continually evaluates the condition before each iteration.

let counter = 5;
while (counter > 0) {
  console.log(counter);
  counter--;
}

A do while loop in JavaScript is a control structure that allows you to execute a block of code repeatedly as long as a specified condition is true. Unlike the for or while loops, a do while loop guarantees that the code block will execute at least once, even if the condition is initially false. The structure of a do while loop is as follows. The code block is executed first, then the condition is checked. If the condition is true, the loop continues and the code block is executed again. If the condition is false, the loop terminates.
 
let roll = 1;
do {
  console.log("Roll: " + roll);
  roll++;
} while (roll <= 6);

For loops are used when you know the exact number of iterations while, while and do while loops are used when the number of iterations is condition dependent. For loops have an explicit initialization step within the loop header, while while and do while loops require you to initialize the loop control variable before the loop. Do while loops guarantee that their body is executed at least once, while for and while loops may not execute the body at all if the initial condition is false.

In JavaScript, functions can be categorized into two main types based on their parameters, inputs, non-parameterized functions and parameterized functions.

Non-parameterized functions do not require any parameters to operate. They can perform their tasks without receiving any specific input values. Non-parameterized functions are often used for tasks that rely solely on their internal logic or external factors. Parameterized functions except one or more parameters, also called arguments that provide input data for the function to work with. You define these parameters in the function's declaration, and when you call the function, you pass specific values for those parameters.

Parameters are variables you define in the function declaration to accept input values. Arguments are the actual values you pass to a function when calling it.

There are two ways of writing a function in JavaScript, function declaration, function expression.

Function declaration is the traditional way to define a function. We start by declaring it using the keyword function, then we write the function name and the parameters.

Function expression is another way to define a function in JavaScript. Here we define a function using a variable and store the returned value in that variable.

Types of functions in JavaScript: named function, immediately invoked function expression, IIFE, arrow function and anonymous function.

Named functions have specific names that can be called by their names. They are typically declared using the function keyword and can be defined at any point in your code. Named function expressions are beneficial for debugging because they display the function's name in the call stack, aiding and identifying and tracking bugs in your code.

Immediately invoked function expression, or IIFE, is a function in JavaScript that's defined and executed immediately after its creation. It's often employed to encapsulate variables and code within a private scope, helping to prevent global scope contamination and variable conflicts. 

The arrow function is a more concise way to write functions introduced in ES6. They are often used for short, simple functions. 

Anonymous functions are without a name. These are often used as arguments for other functions or assigned to variables. For example, you can create anonymous functions using the arrow function syntax.

Arrow functions are especially useful for simple one liner functions. Here's an overview of arrow functions. Arrow functions have a more compact and readable syntax. They use a fat arrow to define the function, which is why they're commonly referred to as arrow functions. Arrow functions do not require the function keyword.

const multi = (a, b) => a * b;

Arrow functions can be categorized in two ways, parameterized and non parameterized functions.

const greet = () => {
    return `Hello, World!`;
}

The return statement is used to produce an output value from a function. This output can be a specific data value, a calculated result, or even another function. It serves as an exit point for a function. Once a return statement is encountered, the function terminates and the control flow is handed back to the code that called the function. Return enables functions that can be used in various contexts because they provide results that can be captured and used by other parts of your code.

document.getElementById ('length'): This part of the code retrieves an HTML element by its ID, specifically searching for an element with the ID 'length'.

.value: After accessing the HTML element, .value is used to retrieve the value entered into the input field associated with that element. For instance, if a user enters '5' into the input field for length, .value retrieves the string '5'.

parseFloat(…): The parseFloat() function converts the string value retrieved from the input field to a floating-point number. This conversion ensures that the input, typically text entered by the user, is treated as a number and can be used in mathematical operations.

.innerText = `The area of the rectangle is: ${area}`;: Once the element is accessed, .innerText is used to modify the text content within that HTML element.

The backticks and ${} notation allow for the inclusion of JavaScript variables within a string (using template literals).

In Javascript, a function closure is a function that retains access to variables from its enclosing function scope. Even after the enclosing function has finished executing, closures allow you to create private variables, implement data hiding, and maintain state between function calls.

Example closure function- In this example, inner function is a closure because it can access the outer var variable from its containing function, outer function, even after outer function has finished executing.

function outerFunction() {
  const outerVar = "I am outside!";
  function innerFunction() {
    console.log(outerVar); // innerFunction has access to outerVar
  }
  return innerFunction;
}

const closure = outerFunction();
closure(); // This will log "I am outside!"

Benefits- 
  1) Data Encapsulation: Closures allow you to encapsulate data within a function scope. Creating a private environment for variables. This is crucial for building modular and maintainable code. As it helps prevent unintended interference or modification of variables from outside the function.

  2) Information Hiding: By using closures, you can hide certain data and expose only the necessary parts of your code's functionality.

Closures enable functions to remember and maintain state between function calls. This is valuable for tasks like implementing counters, timers, or managing application state in event driven programming.

Function hoisting, is a behavior in Javascript where function declarations are moved to the top of their containing scope during the compilation phase, allowing you to use a function before it's actually declared in the code. This behavior only applies to function declarations, not function expressions.

Example: 
sayHello();
// This works even though the function is called before it is defined

function sayHello() {
  console.log("Hello");
}

greet(); // This will result in an error because greet is an expression and it is not hoisted

const greet = function () {
  console.log("Hello there");
};

Benefits:
Function hoisting can make code more readable and self explanatory, by allowing you to use functions before they are defined in the code. This can improve the logical flow of your code, and make it easier to understand. Hoisted functions can be defined at any point within their containing scope, regardless of the order in which they are called. This flexibility can be helpful when structuring your code and organizing related functions. Function hoisting is crucial for recursive functions, as it allows the function to call itself within its own definition. You can conditionally execute functions based on certain criteria without having to define them in a specific order.

In Javascript, events are crucial for creating interactive and dynamic web applications, these are actions or occurrences in the browser, such as user interactions, page loading, or mouse movements over elements. Some of the common events in Javascript are click, mouse over, keydown, and change.
Click event is triggered when a user clicks on an element like a button, mouse over event is triggered when the mouse cursor enters an element like a div, keydown event is triggered by pressing down on a key on the keyboard, and change event is triggered when the value of an input element changes.

Using addEventListener brings several benefits

Readability and maintainability: Decoupling JavaScript from HTML enhances code comprehension and maintenance.

Scalability: As your codebase expands, managing event listeners becomes more straightforward. addEventListener enables easy addition or modification of listeners without HTML changes.

Code reusability: Assigning named functions (for example: handleButtonClick) as event handlers fosters reusable code applicable across various elements or events.

Consistency and best practices: Leveraging addEventListener aligns with modern JavaScript practices, promoting clean code separation and adhering to unobtrusive JavaScript principles.

Multiple event handlers: A single element can host multiple event handlers for the same event, providing flexibility in managing diverse functionalities triggered by one event.

The general syntax for addEventListener is:

element.addEventListener(eventType, handlerFunction)

element: Refers to the HTML element to which you want to attach the event listener.

event type: Specifies the type of event to listen for (for example: 'click', 'change', 'mouseover', and so on).

handlerFunction: JSON stores configuration settings, application states, and structured data in databases or files due to its simplicity and ease of use

Events
JavaScript events represent user-initiated actions in a web browser, such as mouse and keyboard actions and form or window events, enabling dynamic and interactive web experiences.

1) Mouse events:
Mouse events in JavaScript pertain to interactions with the mouse pointer in a web document, including clicks, movements over elements, entering/exiting areas, and dragging elements

A) Click event: The click event triggers when a mouse button is pressed and released on an element, indicating a user interaction. In the example, a button with the ID 'clickButton' has a click event listener attached. When clicked, an alert with 'Button clicked!' appears.

// <button id="clickButton">Click Me!</button>
<script>
  document.getElementById('clickButton').addEventListener('click', function() {
    alert('Button clicked!');
  });
</script>

B) Mouseover: Mouseover occurs when the mouse enters an element; mouseout happens when it leaves.

// <div id="moveArea" style="width: 200px; height: 200px; background-color: lightcoral;"></div>
<script>
  const moveArea = document.getElementById('moveArea');
  moveArea.addEventListener('mousemove', function(event) {
    console.log(`Mouse coordinates - X: ${event.clientX}, Y: ${event.clientY}`);
  });
</script>

This code creates an HTML <div> element (moveArea) with a light coral background. It attaches a 'mousemove' event listener to moveArea, logging the mouse pointer coordinates to the console on movement.

2) Keyboard events:
JavaScript's keyboard events, involving key presses, releases, or holds, encompass 'keydown' (press), 'keyup' (release), and 'keypress' (press and hold). These events capture keyboard input, enabling actions based on specific key presses.

A) Keyup and Keydown: 

// <input type="text" id="keyInput">
<script>
  const keyInput = document.getElementById('keyInput');
  keyInput.addEventListener('keydown', function() {
    console.log('Key pressed down!');
  });
  keyInput.addEventListener('keyup', function() {
    console.log('Key released!');
  });
</script>

The code includes creating an HTML <input> field named keyInput and adding event listeners for both 'keydown' and 'keyup' events to this input field. Whenever a user presses a key within the input field, the console logs the message 'Key pressed down!'. Similarly, upon releasing the key, the console logs 'Key released!'.

B) Keypress:

// <input type="text" id="pressInput">
<script>
  const pressInput = document.getElementById('pressInput');
  pressInput.addEventListener('keypress', function() {
    console.log('Key pressed!');
  });
</script>

This code created <input> field (pressInput) in HTML and added an event listener for 'keypress' to pressInput. On pressing a key in the input field, the console logs 'Key pressed!'

3) Submit events:
Form events in JavaScript are specific events associated with HTML forms and their elements. These events enable developers to capture and respond to user interactions or changes within form elements.

A) Submit event:
Activated when a user submits the form, either by clicking a submit button or programmatically using JavaScript. This event enables developers to handle form data, perform validation, or prevent default submission behavior.

// <form id="myForm">
  <input type="text" id="textInput">
  <input type="submit" value="Submit">
</form>
<script>
  document.getElementById('myForm').addEventListener('submit', function(event) {
    event.preventDefault(); // Prevents the default form submission behavior
    console.log('Form submitted!');
  });
</script>

The code establishes an HTML form with a text input and a submit button. An event listener on the form captures the 'submit' event. Upon submission, the listener triggers a function preventing default behavior and logging 'Form submitted!' to the console.

B) Change event:
Used when the value of an input element within the form changes. It applies to various form elements such as text inputs, checkboxes, radio buttons, and dropdowns. This event enables real-time validation, updates, or actions based on user input changes.

C) Focus event:
Focus event triggers element attention (for example: clicks, tabs). These events are useful for providing visual cues, validation messages, or triggering actions when users interact with form elements.

// <input type="text" id="textInput" placeholder="Click here">
<script>
  const textInput = document.getElementById('textInput');
  textInput.addEventListener('focus', function() {
    console.log('Input focused');
  });
  textInput.addEventListener('blur', function() {
    console.log('Input blurred');
  });
</script>

The code creates a text input in HTML with placeholder text and adds 'Focus' and 'blur' event listeners to the input. When the input gains focus, the 'focus' listener logs 'Input focused', and when it loses focus, the 'blur' listener logs 'Input blurred' to the console.

4) Window events:
Window events in JavaScript handle browser windows or document changes, triggering actions for developers to capture and respond to specific states or behaviors.

A) Load event: 
Used when the entire document and its dependent resources (like images and stylesheets) finish loading, indicating that the page is ready.

<script>
  window.addEventListener('load', function() {
    console.log('Page and all resources loaded');
  });
</script>

This event adds an event listener to the window object for the 'load' event. When the document and its resources finish loading, the function logs 'Page and all resources loaded' to the console.

B) Resize event:
Starts when the browser window changes size, enabling adjustments or responses to alterations in window dimensions

<script>
  window.addEventListener('resize', function() {
    console.log('Window resized');
  });
</script>

This code adds an event listener to the window object, listening for the 'resize' event. When the browser window resizes, triggers a function logging 'Window resized' to the console.

C) Scroll event:
It occurs when ther is the detection of scrolling actions within the document.

// <div style="height: 2000px; background-color: lightblue;">
  Scroll down
</div>
<script>
  window.addEventListener('scroll', function() {
    console.log('Document scrolled');
  });
</script>

This code creates a <div> in HTML for scrolling and adds an event listener to the window, listening for the 'scroll' event. When the user scrolls the document view, the 'scroll' event triggers a function that logs 'Document scrolled' to the console.

JavaScript provides a variety of built-in methods to perform operations on arrays, including push, pop, shift, unshift, splice, slice, concat, map, filter, and many more.

You can iterate through the elements of an array using loops, like for loops, or more modern methods like forEach map, filter, and reduce.

JavaScript offers several built-in array methods to manipulate arrays efficiently, such as push, pop, shift, unshift, splice, concact, slice, indexOf, reverse, sort, and length property.

The push method adds one or more elements to an array's ends and returns the array's new link.
The pop method removes the last element from an array and returns that element.
The shift method removes the first element from an array and returns that element.
The unshift method adds one or more elements to an array's beginning, and returns the array's new link.
The splice changes the contents of an array by removing, replacing or adding elements at a specific position. 
The concat method combines two or more arrays to create a new array without modifying the original ones.
The slice method returns a shallow copy of a portion of an array into a new array without modifying the original content.
The indexOf method finds the index of a specified element within an array. It returns the index of the first occurrence of the element, or minus one, if it is not able to find the element.
The reverse method reverses the order of elements, effectively reversing the array in place.
The sort method is used to sort the elements of an array. By default, it sorts elements as strings and in lexicographic order, to sort numbers correctly, you can provide a comparison function.
The length property returns the number of elements in the array. You can use it to determine the size, or to resize an array by changing its length.

The common array methods used to handle various tasks are forEach, map, filter, reduce, and find.

 The forEach method iterates through an array, and applies a provided function to each element. It's commonly used when you want to perform a specific action for each element, without creating a new array.

function sendWelcomeEmail(username, email) {
  console.log(`Welcome email sent to ${username} on ${email}`);
}
const users = [
  { name: "Sam", email: "samester2@gmail.com" },
  { name: "Alex", email: "alexnet@gmail.com" },
  { name: "John", email: "papajohnes@gmail.com" },
];

users.forEach((user) => {
  sendWelcomeEmail(user.name, user.email);
});

The map method creates a new array by applying a provided function to each element in the original array. It's perfect for transforming data without modifying the original array.

The filter method creates a new array containing elements that pass a specified condition. It's useful for extracting specific data from an array.

const products = [
  {
    name: "laptop",
    price: 1000,
  },
  {
    name: "desktop",
    price: 1500,
  },
  {
    name: "phone",
    price: 500,
  },
];

function filterProductsByPrice(products, minPrice, maxPrice) {
  return products.filter(
    (product) => product.price >= minPrice && product.price <= maxPrice
  );
}

const minPrice = 500;
const masPrice = 1100;

const filteredProducts = filterProductsByPrice(products, minPrice, masPrice);

filteredProducts.forEach((product) => {
  console.log(`Product name: ${product.name}, price: ${product.price}`);
});

The reduce method allows you to reduce an array to a single value by applying a function to each element. It's excellent for aggregating data. 

const orderPrices = [10, 40, 30, 20, 50, 10, 40, 30, 20, 50];

const totalOrderValue = orderPrices.reduce((total, price) => total + price, 0);

console.log(totalOrderValue); // 300

In the reduce function, the second argument (in this case, 0) is the initial value of the accumulator (total in your example).

Here's why we have 0 there:

Initial Value:The second argument (0 in this case) specifies the initial value of the accumulator (total). It's the starting value that the accumulator takes before iterating over each element of the array.
Accumulator:In your example, the accumulator (total) is used to accumulate the sum of all elements in the orderPrices array. For each iteration, the current element of the array (price) is added to the accumulator (total).
By providing 0 as the initial value, you're starting the accumulation process from 0. If you didn't provide an initial value, the first element of the array would be used as the initial value of the accumulator, and the reduction would start from the second element.

So, in this case, the 0 is there to ensure that the accumulator (total) starts from 0 and then sums up all the elements of the orderPrices array. It's the starting point for the accumulation process.

The find method returns the first element in an array that satisfies a specified condition. It's useful for searching for specific data.

const numbers = [10, 20, 30, 40, 50];

const foundNumber = numbers.find(number => number > 25);

console.log(foundNumber); // Output: 30

A class is a blueprint or template for creating objects in JavaScript. It defines the structure and behavior by encapsulating data, or properties, and methods, or functions that are common to a group of objects.

Classes provide a way to model real-world entities, bringing a level of abstraction to your code.

Objects are specific instances of a class created based on the class blueprint. They represent specific entities on unique values for the properties defined in the class. Objects encapsulate state or property values and behavior or methods in a single unit.

class person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  greet() {
    console.log(
      `Hello, my name is ${this.name} and I am ${this.age} years old.`
    );
  }
}

const person1 = new person("John", 30);
const person2 = new person("Jane", 25);

person1.greet();
person2.greet();

Object literals are a way to create ad hoc objects without defining a class. JavaScript objects are prototypes and can inherit properties and methods from other objects.

const person = {
  firstName: "John",
  lastName: "Doe",
  age: 30,
  greet: function () {
    console.log(
      `Hello, my name is ${this.firstName} ${this.lastName} and I am ${this.age} years old.`
    );
  },
};

Function constructors are regular JavaScript functions used to create and initialize objects. It's a convention to name functional constructors with an initial capital letter.

You can create objects using classes or object literals for one-off instances and use function constructors for structured, shared properties and methods. Function constructors are ideal for creating multiple instances of objects with common characteristics. They offer a more organized approach to object creation, aligning with object-oriented programming principles.

In JavaScript, you can access objects and their properties using dot or bracket notations.
Dot notation is the most common way to access object properties. You use a dot followed by the property name.
Bracket notation is an alternative way to access object properties, especially useful when property names contain special characters or spaces. Bracket notation is also handy when you need to access properties dynamically, such as with variables.

An array of objects is a common and powerful way to store and manage structured data in JavaScript. They allow you to organize and manipulate data in a structured manner by combining the features of both arrays and objects.

Create an array of objects by placing objects inside an array using square brackets.

You can access elements within an array of objects using the array index, and then you can access object properties using dot notation. You can modify objects in the array by assigning new values to their properties.

You can loop through an array of objects to perform operations on each object. Common methods for iterating through arrays include for loop and array methods like foreach.

You can add new objects to the array using the push method. You can also remove objects using the pop method.

Array methods like filters and maps are powerful tools for working with arrays of objects. You can use them to filter and transform arrays of objects. You can search for objects within an array of objects using array methods like find.

You can search for substrings within a string using methods like index of, last index of, and includes. 
The includes method checks if the string is found within the sentence, and returns true. 
The indexOf method returns the index or position of the first occurrence of a string in a sentence.

To extract a portion of a string, you can use the substring slice or substr methods. They allow extracting specific portions based on character positions and provide flexibility. 

For instance, in this code, you have a string text with the value Hello, World!. The substring method extracts a portion of the text string starting from index 0 and ending before index 5. It retrieves the characters hello. The slice method extracts a portion of the text string starting from index seven until the end. It retrieves the characters world!. The substr method extracts a substring starting from index 7 and spanning five characters. It retrieves the characters world.

const text = `Hello, world!`;
const sub1 = text.substring(0, 5); // 'Hello'
const sub2 = text.slice(7); // 'world!'
const sub3 = text.substr(7, 5); // 'world'

The replace method is used on the text string. It finds the first occurrence of world and replaces it with universe.

const updatedText = text.replace('world', 'universe'); // Hello, universe!

You can split a string into an array of substrings using the split method. It is handy for parsing data separated by a specific character or sequence of characters for further processing or analysis.

const csvData = `Alice, 25, NYC, 1000; Bob, 30, LA, 1500; Charlie, 35, Chicago, 2000; David, 40, Houston, 2500; Eve, 45, Boston, 3000; Frank, 50, Seattle, 3500; Grace, 55, Miami`;
const csvArray = csvData.split("; ");
console.log(csvArray); // ['Alice, 25, NYC, 1000', 'Bob, 30, LA, 1500', 'Charlie, 35, Chicago, 2000', 'David, 40, Houston, 2500', 'Eve, 45, Boston, 3000', 'Frank, 50, Seattle, 3500', 'Grace, 55, Miami']

The trim method removes leading and trailing white space from a string. It is especially useful for cleaning and formatting user input or working with data from external sources.

Template literals provide a powerful and readable way to format strings. Template literals are enclosed by backticks and allow you to embed expressions within the string using dollar sign syntax.

When you need randomness in your code, you can utilize the math object to generate random numbers.
Math.random()

Date objects are used to represent specific moments in time.
const currentDate = new Date();
const specificDate = new Date(2023, 0, 15);

Timing functions are essential for controlling the flow of your Javascript code. They enable you to create delays, schedule repetitive tasks, and manage animations. There are two types of timing functions, set timeout function and set interval function.

The set timeout function schedules the execution of a function after a specified delay in milliseconds.

setTimeout(function () {
  console.log("Hello from notes_helper.js");
}, 1000); // Display after 1 second
During the one second delay, the rest of the program continues to execute.

Set interval is a built in Javascript function that schedules the repeated execution of a specified function at a specified time interval.

let count = 0;
const intervalID = setInterval(() => {
  console.log(`Hello World ${count}`);
  count += 1;
  if (count === 5) {
    clearInterval(intervalID);
  }
}, 1000); // Display Hello World every 1 second

If the count reaches 5, the arrow function stops using the interval.
