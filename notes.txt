In JavaScript, variables are used to store and manage data. Variables act as containers for various types of information or values. You can think of a variable as a named storage location that holds data, and you can use this data in your JavaScript code.

To create a variable in JavaScript, you also need to declare it using one of three keywords, var, let, or const. The declaration tells JavaScript that you want to reserve a spot in memory to store data.

Var was the original way to declare variables in JavaScript, and it has function level scope. This means that a variable declared with var is available throughout the entire function in which it is declared.

Let was introduced in ES6 and provides block level scoping. This means, that a variable declared with let is only available within the block enclosed by curly braces in which it is defined. This scope is more predictable and less error prone.

Const is also introduced in ES6 and is used to declare variables with constant values. Once you assign a value to a const variable, you cannot reassign it a different value. It also has block level scoping. Const variables are often used for values that should not change, such as mathematical constants or references to immutable objects.

Variable names must start with a letter, underscore, or dollar sign, and can contain letters, numbers, underscores, and dollar signs. Variable names are case sensitive.

Variables declared with let can be reassigned, but not redeclared within the same block. 
Valid: 
{
  let a=9;
  a=12;
}

Invalid:
{
  let a=0;
  let a=12; // will give error
}

Variables declared with let can be reassigned, but not redeclared within the same block. 

JavaScript is a dynamically typed language, which means that you don't need to explicitly specify the data type of a variable when you declare it. The data type is determined dynamically at runtime based on the value you assign to the variable.

JavaScript has several built-in data types, which can be categorized into the following major categories. Primitive data types, composite data types.

Primitive:
Strings represents text. A string is enclosed in single or double quotes. Number represents both integers and floating-point numbers. Boolean represents true or false values. Undefined represents a variable that has been declared, but hasn't been assigned a value. Null represents an empty value or absence of any object value.

Composite: 
Composite data types are those that can hold and manage multiple values as a single unit. These data types are used to organize and manipulate collections of data.

Array and object are two composite data types. An array in JavaScript is a list like data structure for storing multiple value. While an object is a collection of key value pairs used for structured data storage. JavaScript's dynamic typing allows variables to change data types during execution.

Operators in JavaScript are special symbols or keywords used to perform operations on variables and values. JavaScript supports a variety of operators, including: arithmetic operators, comparison operators, logical operators, assignment operators, unary operators, and typeof operators.

Arithmetic operators are used for basic mathematical calculations. Common arithmetic operators include: addition, subtraction, multiplication, division, and modulus. 

Comparison operators are used to compare two values or variables and return a Boolean true or false result. Common comparison operators include: equality, inequality, strict equality, strict inequality, less than, greater than, less than or equal to, and greater than or equal to.

# Example
let a = 5;
let b = 6;

let isEqual = a == b; // equality
let isNotEqual = a != b; // inequality
let isStrictEqual = a === b; // strict equality
let isStrictNotEqual = a !==b; // strict inequality
let isGreaterThan = a > b; // greater than
let isLessThan = a < b; // less than
let isGreaterOrEqual = a >= b; // greater than or equality
let isLessOrEqual = a <= b; // less than or equality

Logical operators are used to combine or manipulate Boolean values. Common logical operators include logical AND, logical OR, and logical NOT.
&& - AND
|| - OR
! - NOT

Unary operators operate on a single value or variable. Common unary operators include increment and decrement.
let a = 5;
a++;
a--;

The typeof operator is a built-in operator in JavaScript that allows you to determine the data type of a variable or an expression. It returns a string representing the type of operand.

The possible return values for typeof are: "Undefined" if the variable is declared but not defined, "Object" for objects, arrays, and null, "Boolean" for Boolean values, "Number" for numbers, and "String" for strings.

let myVar = 42;
let myVarType = typeof myVar;

An expression is a combination of values, variables, and operators that can be evaluated to produce a single value.

Control flow refers to the order in which statements are executed in a JavaScript program. While conditional statements, often referred to as decision making statements, are used to manage this flow based on specified conditions. Some of the conditional statements in JavaScript are if statement, else if statement, else statement, nested if else statement, switch statement, and ternary operator.

let age = 25;
let name = "John";

if (age > 18) {
  console.log("You are an adult");
} else if (age < 18) {
  console.log("You are a minor");
} else {
  console.log("You are a teenager");
}

const temperture = 20;
const isRaining = true;

if (temperature > 18) {
  if (isRaining) {
    console.log("It's warm and raining");
  } else {
    console.log("It's warm and not raining");
  }
} else {
  console.log("It's cold");
}

The switch statement allows you to compare a value against multiple possible case values and execute code based on the first matching case.

let day = "Friday";
switch (day) {
  case "Monday":
    console.log("Today is Monday");
    break;
  case "Tuesday":
    console.log("Today is Tuesday");
    break;
  case "Wednesday":
    console.log("Today is Wednesday");
    break;
  default:
    console.log("Have a nice day");
}

The ternary operator is a concise way to write conditional statements such as if else condition.
let age = 25;
let canVote = age >= 18 ? 'yes' : 'no';

A for loop is a control structure in JavaScript that allows you to execute a block of code repeatedly for a specified number of times, or until a particular condition is met. It consists of three parts, initialization, condition, and update. Initialization, this part is where you initialize a loop control variable, typically with an initial value. Condition, this is a Boolean expression that is evaluated before each iteration. If the condition is true, the loop continues, otherwise it terminates. Update, this part is responsible for changing the loop control variable in each iteration, often incrementing or decrementing its value.

for (let i = 0; i < 10; i++) {
  console.log(i);
} - prints 0 to 9

A while loop is a control structure in JavaScript that allows you to execute a block of code repeatedly. As long as the specified condition is true, it continually evaluates the condition before each iteration.

let counter = 5;
while (counter > 0) {
  console.log(counter);
  counter--;
}

A do while loop in JavaScript is a control structure that allows you to execute a block of code repeatedly as long as a specified condition is true. Unlike the for or while loops, a do while loop guarantees that the code block will execute at least once, even if the condition is initially false. The structure of a do while loop is as follows. The code block is executed first, then the condition is checked. If the condition is true, the loop continues and the code block is executed again. If the condition is false, the loop terminates.
 
let roll = 1;
do {
  console.log("Roll: " + roll);
  roll++;
} while (roll <= 6);

For loops are used when you know the exact number of iterations while, while and do while loops are used when the number of iterations is condition dependent. For loops have an explicit initialization step within the loop header, while while and do while loops require you to initialize the loop control variable before the loop. Do while loops guarantee that their body is executed at least once, while for and while loops may not execute the body at all if the initial condition is false.

In JavaScript, functions can be categorized into two main types based on their parameters, inputs, non-parameterized functions and parameterized functions.

Non-parameterized functions do not require any parameters to operate. They can perform their tasks without receiving any specific input values. Non-parameterized functions are often used for tasks that rely solely on their internal logic or external factors. Parameterized functions except one or more parameters, also called arguments that provide input data for the function to work with. You define these parameters in the function's declaration, and when you call the function, you pass specific values for those parameters.

Parameters are variables you define in the function declaration to accept input values. Arguments are the actual values you pass to a function when calling it.

There are two ways of writing a function in JavaScript, function declaration, function expression.

Function declaration is the traditional way to define a function. We start by declaring it using the keyword function, then we write the function name and the parameters.

Function expression is another way to define a function in JavaScript. Here we define a function using a variable and store the returned value in that variable.

Types of functions in JavaScript: named function, immediately invoked function expression, IIFE, arrow function and anonymous function.

Named functions have specific names that can be called by their names. They are typically declared using the function keyword and can be defined at any point in your code. Named function expressions are beneficial for debugging because they display the function's name in the call stack, aiding and identifying and tracking bugs in your code.

Immediately invoked function expression, or IIFE, is a function in JavaScript that's defined and executed immediately after its creation. It's often employed to encapsulate variables and code within a private scope, helping to prevent global scope contamination and variable conflicts. 

The arrow function is a more concise way to write functions introduced in ES6. They are often used for short, simple functions. 

Anonymous functions are without a name. These are often used as arguments for other functions or assigned to variables. For example, you can create anonymous functions using the arrow function syntax.

Arrow functions are especially useful for simple one liner functions. Here's an overview of arrow functions. Arrow functions have a more compact and readable syntax. They use a fat arrow to define the function, which is why they're commonly referred to as arrow functions. Arrow functions do not require the function keyword.

const multi = (a, b) => a * b;

Arrow functions can be categorized in two ways, parameterized and non parameterized functions.

const greet = () => {
    return `Hello, World!`;
}

The return statement is used to produce an output value from a function. This output can be a specific data value, a calculated result, or even another function. It serves as an exit point for a function. Once a return statement is encountered, the function terminates and the control flow is handed back to the code that called the function. Return enables functions that can be used in various contexts because they provide results that can be captured and used by other parts of your code.

document.getElementById ('length'): This part of the code retrieves an HTML element by its ID, specifically searching for an element with the ID 'length'.

.value: After accessing the HTML element, .value is used to retrieve the value entered into the input field associated with that element. For instance, if a user enters '5' into the input field for length, .value retrieves the string '5'.

parseFloat(…): The parseFloat() function converts the string value retrieved from the input field to a floating-point number. This conversion ensures that the input, typically text entered by the user, is treated as a number and can be used in mathematical operations.

.innerText = `The area of the rectangle is: ${area}`;: Once the element is accessed, .innerText is used to modify the text content within that HTML element.

The backticks and ${} notation allow for the inclusion of JavaScript variables within a string (using template literals).

In Javascript, a function closure is a function that retains access to variables from its enclosing function scope. Even after the enclosing function has finished executing, closures allow you to create private variables, implement data hiding, and maintain state between function calls.

Example closure function- In this example, inner function is a closure because it can access the outer var variable from its containing function, outer function, even after outer function has finished executing.

function outerFunction() {
  const outerVar = "I am outside!";
  function innerFunction() {
    console.log(outerVar); // innerFunction has access to outerVar
  }
  return innerFunction;
}

const closure = outerFunction();
closure(); // This will log "I am outside!"

Benefits- 
  1) Data Encapsulation: Closures allow you to encapsulate data within a function scope. Creating a private environment for variables. This is crucial for building modular and maintainable code. As it helps prevent unintended interference or modification of variables from outside the function.

  2) Information Hiding: By using closures, you can hide certain data and expose only the necessary parts of your code's functionality.

Closures enable functions to remember and maintain state between function calls. This is valuable for tasks like implementing counters, timers, or managing application state in event driven programming.

Function hoisting, is a behavior in Javascript where function declarations are moved to the top of their containing scope during the compilation phase, allowing you to use a function before it's actually declared in the code. This behavior only applies to function declarations, not function expressions.

Example: 
sayHello();
// This works even though the function is called before it is defined

function sayHello() {
  console.log("Hello");
}

greet(); // This will result in an error because greet is an expression and it is not hoisted

const greet = function () {
  console.log("Hello there");
};

Benefits:
Function hoisting can make code more readable and self explanatory, by allowing you to use functions before they are defined in the code. This can improve the logical flow of your code, and make it easier to understand. Hoisted functions can be defined at any point within their containing scope, regardless of the order in which they are called. This flexibility can be helpful when structuring your code and organizing related functions. Function hoisting is crucial for recursive functions, as it allows the function to call itself within its own definition. You can conditionally execute functions based on certain criteria without having to define them in a specific order.

In Javascript, events are crucial for creating interactive and dynamic web applications, these are actions or occurrences in the browser, such as user interactions, page loading, or mouse movements over elements. Some of the common events in Javascript are click, mouse over, keydown, and change.
Click event is triggered when a user clicks on an element like a button, mouse over event is triggered when the mouse cursor enters an element like a div, keydown event is triggered by pressing down on a key on the keyboard, and change event is triggered when the value of an input element changes.

Using addEventListener brings several benefits

Readability and maintainability: Decoupling JavaScript from HTML enhances code comprehension and maintenance.

Scalability: As your codebase expands, managing event listeners becomes more straightforward. addEventListener enables easy addition or modification of listeners without HTML changes.

Code reusability: Assigning named functions (for example: handleButtonClick) as event handlers fosters reusable code applicable across various elements or events.

Consistency and best practices: Leveraging addEventListener aligns with modern JavaScript practices, promoting clean code separation and adhering to unobtrusive JavaScript principles.

Multiple event handlers: A single element can host multiple event handlers for the same event, providing flexibility in managing diverse functionalities triggered by one event.

The general syntax for addEventListener is:

element.addEventListener(eventType, handlerFunction)

element: Refers to the HTML element to which you want to attach the event listener.

event type: Specifies the type of event to listen for (for example: 'click', 'change', 'mouseover', and so on).

handlerFunction: JSON stores configuration settings, application states, and structured data in databases or files due to its simplicity and ease of use

Events
JavaScript events represent user-initiated actions in a web browser, such as mouse and keyboard actions and form or window events, enabling dynamic and interactive web experiences.

1) Mouse events:
Mouse events in JavaScript pertain to interactions with the mouse pointer in a web document, including clicks, movements over elements, entering/exiting areas, and dragging elements

A) Click event: The click event triggers when a mouse button is pressed and released on an element, indicating a user interaction. In the example, a button with the ID 'clickButton' has a click event listener attached. When clicked, an alert with 'Button clicked!' appears.

// <button id="clickButton">Click Me!</button>
<script>
  document.getElementById('clickButton').addEventListener('click', function() {
    alert('Button clicked!');
  });
</script>

B) Mouseover: Mouseover occurs when the mouse enters an element; mouseout happens when it leaves.

// <div id="moveArea" style="width: 200px; height: 200px; background-color: lightcoral;"></div>
<script>
  const moveArea = document.getElementById('moveArea');
  moveArea.addEventListener('mousemove', function(event) {
    console.log(`Mouse coordinates - X: ${event.clientX}, Y: ${event.clientY}`);
  });
</script>

This code creates an HTML <div> element (moveArea) with a light coral background. It attaches a 'mousemove' event listener to moveArea, logging the mouse pointer coordinates to the console on movement.

2) Keyboard events:
JavaScript's keyboard events, involving key presses, releases, or holds, encompass 'keydown' (press), 'keyup' (release), and 'keypress' (press and hold). These events capture keyboard input, enabling actions based on specific key presses.

A) Keyup and Keydown: 

// <input type="text" id="keyInput">
<script>
  const keyInput = document.getElementById('keyInput');
  keyInput.addEventListener('keydown', function() {
    console.log('Key pressed down!');
  });
  keyInput.addEventListener('keyup', function() {
    console.log('Key released!');
  });
</script>

The code includes creating an HTML <input> field named keyInput and adding event listeners for both 'keydown' and 'keyup' events to this input field. Whenever a user presses a key within the input field, the console logs the message 'Key pressed down!'. Similarly, upon releasing the key, the console logs 'Key released!'.

B) Keypress:

// <input type="text" id="pressInput">
<script>
  const pressInput = document.getElementById('pressInput');
  pressInput.addEventListener('keypress', function() {
    console.log('Key pressed!');
  });
</script>

This code created <input> field (pressInput) in HTML and added an event listener for 'keypress' to pressInput. On pressing a key in the input field, the console logs 'Key pressed!'

3) Submit events:
Form events in JavaScript are specific events associated with HTML forms and their elements. These events enable developers to capture and respond to user interactions or changes within form elements.

A) Submit event:
Activated when a user submits the form, either by clicking a submit button or programmatically using JavaScript. This event enables developers to handle form data, perform validation, or prevent default submission behavior.

// <form id="myForm">
  <input type="text" id="textInput">
  <input type="submit" value="Submit">
</form>
<script>
  document.getElementById('myForm').addEventListener('submit', function(event) {
    event.preventDefault(); // Prevents the default form submission behavior
    console.log('Form submitted!');
  });
</script>

The code establishes an HTML form with a text input and a submit button. An event listener on the form captures the 'submit' event. Upon submission, the listener triggers a function preventing default behavior and logging 'Form submitted!' to the console.

B) Change event:
Used when the value of an input element within the form changes. It applies to various form elements such as text inputs, checkboxes, radio buttons, and dropdowns. This event enables real-time validation, updates, or actions based on user input changes.

C) Focus event:
Focus event triggers element attention (for example: clicks, tabs). These events are useful for providing visual cues, validation messages, or triggering actions when users interact with form elements.

// <input type="text" id="textInput" placeholder="Click here">
<script>
  const textInput = document.getElementById('textInput');
  textInput.addEventListener('focus', function() {
    console.log('Input focused');
  });
  textInput.addEventListener('blur', function() {
    console.log('Input blurred');
  });
</script>

The code creates a text input in HTML with placeholder text and adds 'Focus' and 'blur' event listeners to the input. When the input gains focus, the 'focus' listener logs 'Input focused', and when it loses focus, the 'blur' listener logs 'Input blurred' to the console.

4) Window events:
Window events in JavaScript handle browser windows or document changes, triggering actions for developers to capture and respond to specific states or behaviors.

A) Load event: 
Used when the entire document and its dependent resources (like images and stylesheets) finish loading, indicating that the page is ready.

<script>
  window.addEventListener('load', function() {
    console.log('Page and all resources loaded');
  });
</script>

This event adds an event listener to the window object for the 'load' event. When the document and its resources finish loading, the function logs 'Page and all resources loaded' to the console.

B) Resize event:
Starts when the browser window changes size, enabling adjustments or responses to alterations in window dimensions

<script>
  window.addEventListener('resize', function() {
    console.log('Window resized');
  });
</script>

This code adds an event listener to the window object, listening for the 'resize' event. When the browser window resizes, triggers a function logging 'Window resized' to the console.

C) Scroll event:
It occurs when ther is the detection of scrolling actions within the document.

// <div style="height: 2000px; background-color: lightblue;">
  Scroll down
</div>
<script>
  window.addEventListener('scroll', function() {
    console.log('Document scrolled');
  });
</script>

This code creates a <div> in HTML for scrolling and adds an event listener to the window, listening for the 'scroll' event. When the user scrolls the document view, the 'scroll' event triggers a function that logs 'Document scrolled' to the console.

JavaScript provides a variety of built-in methods to perform operations on arrays, including push, pop, shift, unshift, splice, slice, concat, map, filter, and many more.

You can iterate through the elements of an array using loops, like for loops, or more modern methods like forEach map, filter, and reduce.

JavaScript offers several built-in array methods to manipulate arrays efficiently, such as push, pop, shift, unshift, splice, concact, slice, indexOf, reverse, sort, and length property.

The push method adds one or more elements to an array's ends and returns the array's new link.
The pop method removes the last element from an array and returns that element.
The shift method removes the first element from an array and returns that element.
The unshift method adds one or more elements to an array's beginning, and returns the array's new link.
The splice changes the contents of an array by removing, replacing or adding elements at a specific position. 
The concat method combines two or more arrays to create a new array without modifying the original ones.
The slice method returns a shallow copy of a portion of an array into a new array without modifying the original content.
The indexOf method finds the index of a specified element within an array. It returns the index of the first occurrence of the element, or minus one, if it is not able to find the element.
The reverse method reverses the order of elements, effectively reversing the array in place.
The sort method is used to sort the elements of an array. By default, it sorts elements as strings and in lexicographic order, to sort numbers correctly, you can provide a comparison function.
The length property returns the number of elements in the array. You can use it to determine the size, or to resize an array by changing its length.

The common array methods used to handle various tasks are forEach, map, filter, reduce, and find.

 The forEach method iterates through an array, and applies a provided function to each element. It's commonly used when you want to perform a specific action for each element, without creating a new array.

function sendWelcomeEmail(username, email) {
  console.log(`Welcome email sent to ${username} on ${email}`);
}
const users = [
  { name: "Sam", email: "samester2@gmail.com" },
  { name: "Alex", email: "alexnet@gmail.com" },
  { name: "John", email: "papajohnes@gmail.com" },
];

users.forEach((user) => {
  sendWelcomeEmail(user.name, user.email);
});

The map method creates a new array by applying a provided function to each element in the original array. It's perfect for transforming data without modifying the original array.

The filter method creates a new array containing elements that pass a specified condition. It's useful for extracting specific data from an array.

const products = [
  {
    name: "laptop",
    price: 1000,
  },
  {
    name: "desktop",
    price: 1500,
  },
  {
    name: "phone",
    price: 500,
  },
];

function filterProductsByPrice(products, minPrice, maxPrice) {
  return products.filter(
    (product) => product.price >= minPrice && product.price <= maxPrice
  );
}

const minPrice = 500;
const masPrice = 1100;

const filteredProducts = filterProductsByPrice(products, minPrice, masPrice);

filteredProducts.forEach((product) => {
  console.log(`Product name: ${product.name}, price: ${product.price}`);
});

The reduce method allows you to reduce an array to a single value by applying a function to each element. It's excellent for aggregating data. 

const orderPrices = [10, 40, 30, 20, 50, 10, 40, 30, 20, 50];

const totalOrderValue = orderPrices.reduce((total, price) => total + price, 0);

console.log(totalOrderValue); // 300

In the reduce function, the second argument (in this case, 0) is the initial value of the accumulator (total in your example).

Here's why we have 0 there:

Initial Value:The second argument (0 in this case) specifies the initial value of the accumulator (total). It's the starting value that the accumulator takes before iterating over each element of the array.
Accumulator:In your example, the accumulator (total) is used to accumulate the sum of all elements in the orderPrices array. For each iteration, the current element of the array (price) is added to the accumulator (total).
By providing 0 as the initial value, you're starting the accumulation process from 0. If you didn't provide an initial value, the first element of the array would be used as the initial value of the accumulator, and the reduction would start from the second element.

So, in this case, the 0 is there to ensure that the accumulator (total) starts from 0 and then sums up all the elements of the orderPrices array. It's the starting point for the accumulation process.

The find method returns the first element in an array that satisfies a specified condition. It's useful for searching for specific data.

const numbers = [10, 20, 30, 40, 50];

const foundNumber = numbers.find(number => number > 25);

console.log(foundNumber); // Output: 30

A class is a blueprint or template for creating objects in JavaScript. It defines the structure and behavior by encapsulating data, or properties, and methods, or functions that are common to a group of objects.

Classes provide a way to model real-world entities, bringing a level of abstraction to your code.

Objects are specific instances of a class created based on the class blueprint. They represent specific entities on unique values for the properties defined in the class. Objects encapsulate state or property values and behavior or methods in a single unit.

class person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  greet() {
    console.log(
      `Hello, my name is ${this.name} and I am ${this.age} years old.`
    );
  }
}

const person1 = new person("John", 30);
const person2 = new person("Jane", 25);

person1.greet();
person2.greet();

Object literals are a way to create ad hoc objects without defining a class. JavaScript objects are prototypes and can inherit properties and methods from other objects.

const person = {
  firstName: "John",
  lastName: "Doe",
  age: 30,
  greet: function () {
    console.log(
      `Hello, my name is ${this.firstName} ${this.lastName} and I am ${this.age} years old.`
    );
  },
};

Function constructors are regular JavaScript functions used to create and initialize objects. It's a convention to name functional constructors with an initial capital letter.

You can create objects using classes or object literals for one-off instances and use function constructors for structured, shared properties and methods. Function constructors are ideal for creating multiple instances of objects with common characteristics. They offer a more organized approach to object creation, aligning with object-oriented programming principles.

In JavaScript, you can access objects and their properties using dot or bracket notations.
Dot notation is the most common way to access object properties. You use a dot followed by the property name.
Bracket notation is an alternative way to access object properties, especially useful when property names contain special characters or spaces. Bracket notation is also handy when you need to access properties dynamically, such as with variables.

An array of objects is a common and powerful way to store and manage structured data in JavaScript. They allow you to organize and manipulate data in a structured manner by combining the features of both arrays and objects.

Create an array of objects by placing objects inside an array using square brackets.

You can access elements within an array of objects using the array index, and then you can access object properties using dot notation. You can modify objects in the array by assigning new values to their properties.

You can loop through an array of objects to perform operations on each object. Common methods for iterating through arrays include for loop and array methods like foreach.

You can add new objects to the array using the push method. You can also remove objects using the pop method.

Array methods like filters and maps are powerful tools for working with arrays of objects. You can use them to filter and transform arrays of objects. You can search for objects within an array of objects using array methods like find.

You can search for substrings within a string using methods like index of, last index of, and includes. 
The includes method checks if the string is found within the sentence, and returns true. 
The indexOf method returns the index or position of the first occurrence of a string in a sentence.

To extract a portion of a string, you can use the substring slice or substr methods. They allow extracting specific portions based on character positions and provide flexibility. 

For instance, in this code, you have a string text with the value Hello, World!. The substring method extracts a portion of the text string starting from index 0 and ending before index 5. It retrieves the characters hello. The slice method extracts a portion of the text string starting from index seven until the end. It retrieves the characters world!. The substr method extracts a substring starting from index 7 and spanning five characters. It retrieves the characters world.

const text = `Hello, world!`;
const sub1 = text.substring(0, 5); // 'Hello'
const sub2 = text.slice(7); // 'world!'
const sub3 = text.substr(7, 5); // 'world'

The replace method is used on the text string. It finds the first occurrence of world and replaces it with universe.

const updatedText = text.replace('world', 'universe'); // Hello, universe!

You can split a string into an array of substrings using the split method. It is handy for parsing data separated by a specific character or sequence of characters for further processing or analysis.

const csvData = `Alice, 25, NYC, 1000; Bob, 30, LA, 1500; Charlie, 35, Chicago, 2000; David, 40, Houston, 2500; Eve, 45, Boston, 3000; Frank, 50, Seattle, 3500; Grace, 55, Miami`;
const csvArray = csvData.split("; ");
console.log(csvArray); // ['Alice, 25, NYC, 1000', 'Bob, 30, LA, 1500', 'Charlie, 35, Chicago, 2000', 'David, 40, Houston, 2500', 'Eve, 45, Boston, 3000', 'Frank, 50, Seattle, 3500', 'Grace, 55, Miami']

The trim method removes leading and trailing white space from a string. It is especially useful for cleaning and formatting user input or working with data from external sources.

Template literals provide a powerful and readable way to format strings. Template literals are enclosed by backticks and allow you to embed expressions within the string using dollar sign syntax.

When you need randomness in your code, you can utilize the math object to generate random numbers.
Math.random()

Date objects are used to represent specific moments in time.
const currentDate = new Date();
const specificDate = new Date(2023, 0, 15);

Timing functions are essential for controlling the flow of your Javascript code. They enable you to create delays, schedule repetitive tasks, and manage animations. There are two types of timing functions, set timeout function and set interval function.

The set timeout function schedules the execution of a function after a specified delay in milliseconds.

setTimeout(function () {
  console.log("Hello from notes_helper.js");
}, 1000); // Display after 1 second
During the one second delay, the rest of the program continues to execute.

Set interval is a built in Javascript function that schedules the repeated execution of a specified function at a specified time interval.

let count = 0;
const intervalID = setInterval(() => {
  console.log(`Hello World ${count}`);
  count += 1;
  if (count === 5) {
    clearInterval(intervalID);
  }
}, 1000); // Display Hello World every 1 second

If the count reaches 5, the arrow function stops using the interval.

Debugging in JavaScript is the process of of identifying and fixing errors, bugs and issues in your JavaScript code. These errors can include syntax errors, logical errors, runtime errors, and other issues that prevent your JavaScript program from functioning as intended.

The simplest form of debugging involves adding console.log statements to your code. These statements allow you to print values, variables or messages to the browser's console. By examining these outputs, you can get insights into the flow of your program and the values of variables at different points in your code.

Most modern web browsers come with built-in developer tools that allow you to set breakpoints in your JavaScript code. When a breakpoint is reached, the code execution stops and you can inspect variables, the call stack, and other relevant information. 

You can insert the debugger statement directly into your code to halt execution and trigger the browser's debugger. This is similar to setting breakpoints, but is initiated programmatically.

Every major web browser, such as Google Chrome, Mozilla Firefox, Microsoft Edge, and Safari, includes developer tools that provide debugging capabilities. You can access these tools by pressing F12 or right-clicking on a web page and selecting inspect or inspect element. In the developer tools, navigate to the console tab for logging, sources or debugger tab for setting breakpoints, and Network tab for debugging network requests.

 A try-catch block in JavaScript is a structured mechanism used for error handling. It allows you to manage and recover from runtime errors that might occur during the execution of your code.

 The code that might generate an error is enclosed within a try block. This is the segment of code that you want to monitor for errors. Catch block, if an error occurs within the try-block, the catch block is executed. The catch block specifies how to handle the error. It takes an error object as a parameter which contains information about the error. The catch block can log the error, provide fallback behavior, or perform any other action to handle the error.

 Catch blocks provide a place to log error information. You can log error information to the console or send them to a server for detailed analysis.  

 The error object passed to the catch block contains valuable information such as the error type, message and stack trace. This information helps you understand what went wrong and where the error occurred. Catch block allows you to define fallback behavior or alternative code paths.

 You can use the throw statement within a try block to throw custom expectations based on specific conditions. This enables you to provide more meaningful error information, aiding in debugging.

 The document object model, or DOM, is a programming interface for web documents. It represents the web page so that programs like JavaScript can change the document structure, content, and style.

 The term document refers to a web page or any XML document such as HTML, XHTML, or XML. The DOM represents this document as a structured tree-like hierarchy with each part represented as a node. An object represents a JavaScript object that corresponds to an element, attribute, or content within the web document. Each DOM element is an element of the web page, accessible and manipulable using JavaScript. The model denotes the structured and abstract representation of a web document. 

 $0 is a special variable that you can use in the browser's development console as a quick reference to the currently selected DOM element in the elements panel in web development. It is often used for debugging and inspecting elements in a web page. 

 Once you have the element referenced with $0, you can interact with it using JavaScript. This includes accessing its properties or modifying its attributes.

DOM is a programming interface that allows JavaScript to modify web document structure, content, and style. Document refers to web pages, objects corresponding to JavaScript objects representing elements, and model signifies the structured representation for programming languages.

$0 is a special console variable for referencing the currently selected DOM element for debugging and inspection. DOM has various types of nodes like document, element, text, attribute, comment, and document-type nodes. And DOM is vital for structured access to web content, creating dynamic web apps, content manipulation, and enhanced user experience, among other functionalities.

Accessing the document object model or DOM means obtaining references to specific HTML elements on a web page.

Accessing elements in the DOM can be done using methods like one, getElementById, two, getElementsByClassName, three, GetElementsByTagName, and four, querySelector.

getElementById is a method in JavaScript used to access a specific HTML element within the DOM based on its unique ID attribute.

You can use the getElementsByClassName method in JavaScript to access multiple HTML elements within the DOM that share the same class name. The result is a collection of elements stored in a variable.

Use the getElementsbyTagName method in JavaScript to access multiple HTML elements within the DOM based on their tag name.

querySelector is a versatile method in JavaScript used to access HTML elements within the DOM based on CSS-like selectors. 

Common Methods of classList

add(class1, class2, ...)
This method adds one or more classes to the element.
element.classList.add('newClass');

remove(class1, class2, ...)
Removes one or more classes from the element.
element.classList.remove('oldClass');

toggle(class, force)
Toggles a class. If the class exists, it is removed; otherwise, it is added. If the second parameter is true, the class is added; if false, the class is removed.
element.classList.toggle('active');

contains(class)
Checks if a class is present on the element. Returns true if the class exists; otherwise, it is false.
if (element.classList.contains('special')) {
  // Do something special
}

replace(oldClass, newClass)
Replaces a class with another class.
element.classList.replace('oldClass', 'newClass');

item(index)
Returns the class name at the specified index.
const firstClass = element.classList.item(0);

toString()
Returns a string representing the element's classes.
const classString = element.classList.toString();

The browser Object model BOM in JavaScript, is a crucial aspect that provides a structured way to interact with the web browser. It allows you to control browser behavior, manipulate the browser window, and access client-specific information. Unlike the document object model (DOM), which represents the web page's content, the BOM deals with the browser's environment. Some of the key components of BOM are as follows, window, document, navigator, screen, history, and location.

The Global Window object represents the browser window or tab, and serves as the root of the BOM. All Global JavaScript objects and functions are part of the window object. The window object encompasses various properties and methods. For instance, window.alert (message) displays a simple alert dialog, window.confirm (message), shows a confirmation dialog, and window.open (url, name, specs, replace) opens a new browser window or tab. You can also close the current window with a window.close, and manipulate the current URL using the window.location. The window object extends its functionalities with features like setTimeout, for delayed function execution and storage options, such as localStorage, and sessionStorage for client-side data storage. Additionally, window.history provides access to the browser session's history.

To integrate BOM methods with HTML, follow these steps. Begin crafting an HTML document with the necessary structure, and a script element for embedding your JavaScript code. Include HTML elements such as buttons, to trigger BOM methods. Develop a JavaScript file, for example, yourscript.js containing the code for employing BOM methods. Link this file to your HTML document using the script tag. Open your HTML file in a web browser to interact with the buttons, and witness the BOM methods. Clicking the buttons, triggers the associated BOM methods. 

The process of traversing the DOM or document object model, involves navigating and manipulating the structure and content of an HTML document using JavaScript. The DOM represents a web page as a hierarchical tree of objects, where each HTML element is a node in the tree. Traversing the DOM allows you to programmatically access, manipulate, and interact with these nodes.

Navigating parent and child elements within the DOM involves moving up and down the tree-like structure of an HTML document using JavaScript. This process is crucial for accessing and manipulating relationships between elements. Several methods and properties are commonly used for navigating parent and child elements. ParentNode property is used to access the parent node of an element. It allows movement up one level in the DOM tree to access elements containing or surrounding the element.

ChildNodes property returns a NodeList containing all child nodes of an element. ChildNodes can include elements, text nodes, comments, and other types of nodes that are direct descendants of the element. Individual child nodes are accessed using their index within the node list. FirstChild and lastChild properties allow access to the first and last child nodes of an element. These are useful for accessing the first and last elements or nodes within a parent element. Let's consider the following HTML structure.

It involves moving horizontally within the hierarchical tree structure of an HTML document. This process allows access and manipulation of elements that share the same parent node. Key methods and properties include: nextSibling and previousSibling properties allow access to the next and previous sibling nodes at the same hierarchical level; include various node types such as elements, text nodes, comments, or other types.

FirstChild and lastChild properties allow access to the first and last child nodes of the current element-- different from navigating siblings, as they go one level deeper into the hierarchical structure.

Styling the DOM elements is crucial for dynamically changing the visual presentation of HTML elements on your web page using CSS properties and styles through JavaScript. This process enhances user interactions and responsiveness, helping to make changes such as altering elements, color, size, position, or visibility in response to user actions or other events. There are several methods for styling DOM elements using JavaScript. Here are some common ones: element.style.property, element.classList, element.setAttribute, element.styles.cssText, element.style.setProperty, and element.style.removeProperty. Let's explore each method in detail.

elements.style.property directly modifies the inline styles of an element by setting CSS properties and values. Element.classList adds, removes, or toggles CSS classes on an element using class list. Element.setAttribute sets or modifies the entire style attribute of an element with a string containing inline CSS properties and values, element.style.cssText sets the entire inline style of an element using the CSS text property. element.styls.setProperty sets a specific CSS property. With an optional priority for an element's inline style. Ensuring it takes precedence over other styles and element.style.removeProperty removes a specific CSS property from an element's inline style, allowing you to reset or adjust styling selectively.

JSON, or JavaScript object notation is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate. It is a text-based format used for structuring data in a way that is both human readable and machine readable.

JSON is widely used for exchanging data between a server and a web application or between different parts of a software system. It serves as a common language for data communication. For example, when you make an API request to a web service, the response is often in JSON format.

JSON is easy for machines to parse, making it a popular choice for data serialization and deserialization. This means that software applications can easily convert JSON data into the internal data structures of the programming language and vice versa.

JSON is simpler than other data interchange formats like XML. It doesn't have the complexity of tags and attributes, making it less verbose and more concise.

JSON can be extended to support additional data types and structures, making it versatile for various use cases. This is typically achieved through custom objects or arrays. 

JSON and objects in programming are related concepts, but they have some key differences. JSON is a text based data interchange format. It represents data as a string, which is a sequence of characters. JSON is a way to serialize and transmit data, primarily used for data exchange between systems or for storing data and files. Whereas an object is a fundamental data structure that can hold data and methods to manipulate that data. Objects are typically used to model real world entities or abstract concepts within a software application. JSON has a specific syntax and rules that must be followed. It uses key value pairs and is limited to a specific set of data types, including strings, numbers, Booleans, arrays and other JSON objects. JSON follows a strict format and keys are enclosed in double quotes. In programming, objects are not restricted to a specific syntax or set of data types. They are a part of the programming language and can include a wide variety of data types, such as integers, floats, custom data structures, and more. JSON is primarily used for data interchange. It is used to transmit data between a client and a server, between different parts of a software system or to store configuration data in files. Its main purpose is to facilitate data transfer and interoperability. While objects in programming are used to model and manipulate data within the application itself, they represent entities or concepts within the program's logic and can encapsulate both data and the methods that operate on that data. 

Synchronous programming in JavaScript refers to the execution of code in a sequential and blocking manner. In a synchronous program, each operation or task is executed one after the other, and the program waits for each task to complete before moving on to the next one. This means that if one operation takes a long time to execute, it can block the entire program's execution, making it unresponsive.

console.log(`Task 1`);
console.log(`Task 2`);
console.log(`Task 3`);

This code will execute the program sequentially. If there is an error in Task 1, then the execution will halt, and we won't reach Task 2 before the error is fixed.

Asynchronous programming in JavaScript is a programming paradigm that allows you to execute code without blocking the main execution thread. It enables tasks to run concurrently, making it particularly useful for handling operations that may take some time to complete, such as network requests, file I/O, or user interactions.

async function fetchData() {
  const response = await fetch('https://api.example.com/data');
  const data = await response.json();
  return data;
}

function readFileAsync(path, callback) {
  fs.readFile(path, 'utf8', (err, data) => { // The readFile function from the fs (File System) module is used to read the contents of a file asynchronously. This is the asynchronous operation in the example.
    if (err) {
      callback(err);
    } else {
      callback(null, data);
    }
  });
}

Callbacks are functions that are passed as arguments to other functions and are executed at a later time, typically when an asynchronous operation completes. They allow you to specify what should happen after the asynchronous task is done. Promises are objects that represent the eventual completion or failure of an asynchronous operation. They provide a cleaner and more structured way to work with asynchronous code compared to callbacks.

Introduced in ES2017, ES8, async/await is a more recent way to work with asynchronous operations. It allows you to write asynchronous code in a more synchronous-looking style, making it easier to read and maintain. JavaScript uses an event loop to manage asynchronous operations. The event loop continuously checks the message queue for tasks that need to be executed, and runs them in the order they were added.

Here's a basic example using the setTimeout function to illustrate asynchronous programming. In this example, start and end will be logged immediately, but delayed message will be logged after a two-second delay, because setTimeout is an asynchronous operation. This demonstrates how asynchronous programming allows non-blocking execution of code.

console.log('Start');

setTimeout(function () => {
  console.log('Delayed Message');
}, 2000); // Introduces a delay of 2 seconds

console.log('End')

// O/P
Start
End
Delayed Message

AJAX, short for asynchronous JavaScript and XML, is a set of web development techniques used to create dynamic and responsive web applications. It enables asynchronous communication between the web browser and the server, allowing data to be exchanged without requiring a full page reload. 

AJAX operates asynchronously, meaning it allows the webpage to send and receive data from the server in the background while the user interacts with the page.

JavaScript is the primary language used to initiate AJAX requests and handle responses. XMLHttpRequest or XHR object is the core technology enabling communication between the browser and the server. It's used to send HTTP requests and handle responses. AJAX was initially associated with XML for data transfer, but later commonly uses JSON due to its simplicity and ease of parsing.

Let's delve into the details of how AJAX operates:
 Typically, an event like a button click triggers an AJAX request within a web page. JavaScript code initiates an XMLHttpRequest object, or uses modern fetch API to send an asynchronous request to the server. The server processes the request, performs necessary operations such as database queries, and generates a response. Upon receiving the response, JavaScript processes the data and updates specific parts of the web page, often without needing a full page reload.

AJAX facilitates smooth and dynamic content updates, leading to a more interactive user interface. By updating only specific portions of the page, AJAX reduces bandwidth usage and server load, enhancing performance. Users can continue interacting with the webpage while data is being fetched or processed in the background.

Use cases:
  You can use AJAX to load additional content on a page without reloading the entire page, as seen in infinite scrolling on social media platforms. It enables sending form data to the server without refreshing the entire page. AJAX plays a vital role in enabling features like live chat or stock market updates without interrupting user activity. Automatically saving feature saves user input without requiring manual submissions.

AJAX best practices:
  Robust error handling mechanisms are essential to manage failed requests or timeouts. Implementing retries or fallback strategies ensures a smoother user experience. Cross-site scripting, XSS, and other security vulnerabilities should be considered when implementing AJAX. Implementing proper authentication and encryption measures is crucial. Understanding and addressing cross-origin restrictions by using cores, cross-origin resource sharing headers, when making requests to different domains.

XMLHttpRequest (XHR) is a JavaScript API that enables communication between a web browser and a server. It allows for making HTTP requests to retrieve data from a server or send data to a server in the background without reloading the entire web page.

You can create an XHR object by following a step-by-step guide explaining the associated properties and method. You can use XMLHttpRequest to fetch data from external APIs or servers managing different data formats such as JSON or XML. With XHR, you can utilize event listeners to handle responses, including response codes like success or failure. Additionally, you can dynamically update web page content based on the received data. You can effectively manage errors and timeouts with XMLHttpRequest. You can use XMLHttpRequest to retrieve data securely, addressing concerns such as cross-origin request.

A callback is a function passed as an argument to another function and executed later or after a specific event occurs. JavaScript commonly uses callbacks to handle asynchronous operations such as event handling, timers, and user interactions.

Sync:
const names = ["Alice", "Bob", "Charlie"];

function getNames(array, cb) { // cb is a callback function
  array.forEach((element) => { // forEach is a method that calls a function once for each element in an array
    cb(element); 
  });
}

getNames(names, (name) => { 
  console.log(name); 
});

Async:
const names = ["Alice", "Bob", "Charlie"];

function getNamesAsync(array, cb) { // cb is a callback function
  setTimeout(() => { // Simulating an asynchronous operation
    array.forEach((element) => { // forEach is a method that calls a function once for each element in an array
      cb(element); 
    });
  }, 0); // Using a timeout of 0 milliseconds to make it asynchronous
}

getNamesAsync(names, (name) => { 
  console.log(name); 
});

Promises are a powerful and flexible way to work with asynchronous operations in JavaScript. They represent a value that may not be available yet, but will be in the future. You can use promises for tasks like fetching data from a server, reading files, or performing other operations that may take time to complete.

Promises have three states. Pending is the initial state when you create the promise and the asynchronous operation is in progress. Fulfilled is when the asynchronous operation is completed and the result is available. Rejected is the state when the asynchronous operation encounters an error or is unsuccessful.

You can create promises using the promise constructor, providing a method to handle the results once the asynchronous operation is complete.

The promise constructor takes a function as an argument with two parameters, resolve and reject. Calling a resolve function indicates completion of the asynchronous operation, and it provides the result of that operation. A reject function, when called, indicates that an error has occurred during the asynchronous operation, and it provides the error information.

After creating the promise, you can use the then method to specify what should happen when the promise is resolved or rejected. Then, the method takes two callback functions as arguments. The first callback function executes when the promise resolves, it receives the result provided by the resolve function. The second callback function executes when the promise is rejected and receives the error information the reject function provides.

const myPromise = new Promise((resolve, reject) => {
  // Asynchronous code
  // If successful, call resolve()
  // If unsuccessful, call reject()
});

myPromise.then(
  () => {
    // Code to run if the promise is resolved
  },
  () => {
    // Code to run if the promise is rejected
  }
);

// Define a function that returns a promise
function getData() {
  // Create a new promise
  return new Promise((resolve, reject) => {
    // Simulate an asynchronous operation (e.g., fetching data)
    setTimeout(() => {
      // Simulate a successful response
      const data = { id: 1, title: "Sample note" };

      // Check if the data was retrieved successfully
      if (data) {
        // Resolve the promise with the data
        resolve(data);
      } else {
        // Reject the promise with an error message
        reject("Failed to fetch data");
      }
    }, 2000); // Simulating a delay of 2 seconds
  });
}

// Call the function that returns a promise
console.log("Fetching data...");
getData()
  // Handle the resolved promise (success case)
  .then((data) => {
    console.log("Data successfully fetched:", data);
  })
  // Handle the rejected promise (error case)
  .catch((error) => {
    console.error("Error fetching data:", error);
  });

Advantages:
  The key advantage of using promises is that they allow you to handle asynchronous operations linearly without needing deeply nested callbacks. This code structure makes understanding and maintaining asynchronous code easier. Which is partially important in real world scenarios involving API requests, data processing, and updating the user interface, UI.

The Fetch API is a modern built-in JavaScript interface for making network requests, typically used for fetching resources from the web, such as data from a server or an API. It provides a more flexible and powerful way to work with HTTP requests than older techniques, like XML HTTP request. 

characteristics:
  The Fetch API promises cleaner and more structured handling of asynchronous operations. It's straightforward and easy to use syntax, facilitating the setup, sending, and handling of requests. Lastly, the Fetch API supports a range of HTTP request methods, including GET, POST, PUT, DELETE, and others.

Axios is a popular JavaScript library used to make HTTP requests from the browser. It provides a simple and consistent API for making asynchronous HTTP requests to interact with RESTful APIs or other web services.

axios({
  method: "HTTP_METHOD",
  url: "URL",
  headers: {
    // Headers (if any)
    // 'Authorization': 'Bearer ' + token
    // 'Content-Type': 'application/json'
    // 'Accept': 'application/json'
  },
  data: {
    // Data to be sent
  },
})
  .then((response) => {
    // Handle response
  })
  .catch((error) => {
    // Handle error
  });

Method refers to the HTTP method for the request like get, post, put, or delete. URL specifies the URL of the resource you want to request from the server. Header is an object that shows you to specify custom headers for the request such as authorization or content type headers. Data represents the request data typically used for post, put, and more. Depending on the content type, it can be an object or a string. The dot then method handles the successful response from the server. It receives a response object that contains the response data, headers and status information. Dot catch method handles errors. It receives an error object with details such as a network time out or server error.

FETCH VS AXIOS
Fetch is a built-in web API in modern browsers. It provides a basic interface for making HTTP requests and is available natively in the browser. It returns promises for asynchronous operations. Meanwhile, Axios is a separate library you must include in your project. It provides a more convenient and high-level API for making HTTP requests. Axios also returns promises for asynchronous operations, but is not built into the browser, so you must include it explicitly. Modern browsers widely support fetch, but may not be available in older browsers without a polyfill. Conversely, Axios is designed to work consistently across different browsers and has better compatibility, including support for older versions of Internet Explorer. Fetch requires more manual configuration of headers and request options, and you need to call additional methods to parse the response body. Axios offers a more intuitive and higher-level API for request configuration and response handling. It automatically parses the response based on the specified data type. Fetch requires explicitly checking the response status and throwing errors for non-okay statuses. Error handling can be more complex and may involve custom logic. Meanwhile, Axios automatically handles response status checks and treats non-okay responses as errors. It provides a more streamlined error-handling process. Fetch does not have built-in support for request cancellation, which can be important when you need to cancel ongoing requests. Whereas Axios provides built-in support for request cancellation using cancel tokens. Fetch does not have built-in interceptor support, so you need to handle these tasks separately. Axios allows you to define requests and response interceptors for tasks like authentication, logging, or global error handling. Fetch requires you to apply these settings to each request manually. Meanwhile, Axios allows you to set global defaults and configurations for headers, base URLs, and other request parameters, making it easier to maintain consistency in your API calls.

Module 4 Summary: JavaScript Async

JSON or JavaScript Object Notation is a lightweight, human-readable, and machine-readable data interchange format.

JSON utilizes key-value pairs and arrays, providing simplicity for both developers and non-developers.

AJAX, or Asynchronous JavaScript and XML, revolutionizes web development by facilitating dynamic and responsive applications.

Advantages of using AJAX include enhanced user interfaces, reduced server load, and uninterrupted user interactions.

Common uses range from dynamic content loading to real-time updates and auto-saving features in social media and e-commerce platforms.

XMLHttpRequest or XHR is a JavaScript API facilitating communication between web browsers and servers.

XMLHttpRequest enables asynchronous HTTP requests, allowing data retrieval or submission without reloading the entire webpage.

Callbacks are functions passed as arguments, executed later or after specific events.

Promises offer a powerful way to handle asynchronous operations.

You can create promises using the promise constructor, taking resolve and reject functions.

The fetch API is a modern JavaScript interface that offers a flexible and powerful approach to fetching resources from the web.

The fetch API supports various HTTP request methods, including GET, POST, PUT, DELETE, PATCH, and OPTIONS.

Axios offers a clean and consistent API for asynchronous interactions with RESTful APIs or web services.

Axios streamlines the process of making HTTP requests, providing a user-friendly interface and additional features that enhance the overall development experience compared to native solutions like Fetch. 

*************************************************************************************************************************

React
A framework is a comprehensive software development platform that provides the foundation and structure for building entire applications. Unlike libraries that offer specific functionalities, frameworks impose a particular architecture and provide tools, libraries, and guidelines to streamline the development process. Frameworks address broader concerns, including handling user requests, managing data flow, and structuring the application's overall architecture. Some popular examples of JavaScript frameworks include AngularJS, Ember JS, Svelte, and Vue.js.

The prominent features of React include component-based architecture, declarative syntax, Virtual DOM, One-way data binding, JavaScript XML (JSX), and hook employment.

React's flexible component-based architecture enables the creation of reusable UI elements.

In React, developers build UIs by composing independent components representing a specific web page feature.

For example, developers can divide a website with headers, left and right sidebars, or footers. This modular approach allows developers to encapsulate UI functionality in individual files, making it easy to reuse components across multiple pages without duplicating the code.

React uses a declarative syntax that updates how the UI should behave when data or states change. This declarative paradigm lets developers focus only on specifying the intended UI behavior, while React efficiently manages the underlying DOM.

 In essence, developers instruct React on what to do rather than how to do it.

 React also utilizes a virtual DOM instead of direct manipulation. React generates virtual DOM copies when changes occur in any component and then compares them with the real DOM, updating only the essential segments. This strategy optimizes performance and improves speed by minimizing unnecessary DOM modifications.

 React implements one-way data binding, ensuring data flows unidirectionally from parent to child components. This approach simplifies data management, reducing the risk of bugs caused by an inconsistent state.

 React also utilizes JSX, JavaScript XML, a JavaScript syntax extension enabling HTML-like code within JavaScript. JSX makes creating and visualizing UI components easier.

 React employs hooks, a feature introduced in React 16.8. Hooks allow developers to handle states and other React features seamlessly, eliminating the need for class-based coding. Hooks simplify component logic, promote code reuse, and make it easier to manage stateful behavior.

-------------------------------------------------------------------------------------------------------------------------
ES is short for EcmaScript. Ecma is a standards organization that creates a wide range of global information and communications technology standards. JavaScript adheres to Ecma’s specification ES6, which came out in 2015.

Object-oriented programming was made feasible in JavaScript with the introduction of class. Class is a template or blueprint for creating objects. Classes in JavaScript are built on prototypes. Prototype is a property of all JavaScript objects, including functions. A function can be used to create an object instance.

In JavaScript ES6, a class can inherit from another class. The class that is inheriting one other class is called the subclass. The superclass is the class being inherited by the subclass. The subclass inherits all the attributes and methods of the superclass.

React components use inheritance to build user-defined components. The subclass has a special privilege to call the superclass constructor with the super() method call. 

There are several advantages to using TypeScript rather than JavaScript in your React application and possibly a few drawbacks. Regarding advantages:

TypeScript makes it easy to define Prop types in React. This makes writing code with an IDE that supports code completion a breeze since the IDE automatically populates the Prop type.

Most common third-party libraries support TypeScript definitions.

As mentioned, TypeScript has static type-checking, which enables you to help identify errors earlier in the development process.

Refactoring code becomes easier since types are known.

There will be fewer “undefined” errors at run-time due to type-checking at compile time.

Code is easier to read and maintain than JavaScript due to typed variables.

You can still write JavaScript and use the TypeScript compiler.

JSX or JavaScript Syntax Extension or JavaScript XML is an extension to JavaScript. It provides an easier way to create user interface or UI components in React.

JSX produces React “elements” that can be used to render the component to Document Object Model or DOM. The JSX syntax is like an XML or HTML-like syntax used by React that extends ECMAScript that is a standard used for client-side scripting.

The JSX syntax is intended to be used by preprocessors, for example, transpilers or compiler like Babel, to transform HTML-like text found in JavaScript files into standard JavaScript objects. These objects can then be parsed by a JavaScript engine.

const el1 = <h1>This is a sample JSX code snippet</h1>
Like HTML uses tags
Like JS uses constructs (const el1 = )

JSX is basically a syntax extension of regular JavaScript and is used to create React elements. These elements are then rendered to the React Document Object Model or DOM.

JSX makes React code much easier to read, write, and understand.

Benefits of using JSX:
- Less technical people can understand and modify the required parts. 
- CSS developers and designers will find JSX more familiar than JavaScript alone. 
- You can also leverage the full power of JavaScript in HTML and avoid learning or using a templating language. 
- By adding a JSX transformation step you'll find errors in your HTML you might otherwise miss. 
- JSX promotes the idea of inline styles. When writing large pieces of code, JSX helps you in keeping your code simple and elegant.
-  Also JSX is faster than normal JavaScript as it performs optimizations while translating to regular JavaScript.
- JSX takes care of the usual output sanitization issues to prevent attacks such as cross-site scripting.

Components are the building blocks of React applications and make building complex user interfaces easier by breaking down the UI into individual pieces. Then you merge them into a parent component that forms what the user sees and interacts with.

React components enable you to break up the user interface into separate elements. These can then be reused and handled independently. 

A React component takes on optional input and returns a React object, which is rendered on the screen. The React component renders pieces of the web page.

You develop the components code so it knows how to behave and update when the user interacts with it. This modification of the component is called a state change. You also manage events such as selecting a button with a component state.

You use a component's properties to store and pass data from a parent to a child component. 

Events manage the document object model, DOM, as a result of the user's interaction with the system. You use a component state to update the UI. 

React has three types of components: class, functional, and higher-order.

Functional components are written like JavaScript functions. They can take arguments and return JSX.
const demoComponent = () => {
  return <h1>Welcome Message!</h1>;
}
In the code, the function Democomponent returns the phrase Welcome Message as JSX. 

You can use JavaScript ES6 classes to create class-based components in React. You can pass data from one class component to another class component. They use the main React functions such as state, props, and lifecycle methods. After the introduction of hooks in version 16.8, developers tend to prefer functional over class components because class components are more complex.

A higher-order component, HOC, allows you to reuse component logic. You can compose components together by taking a component as an argument to another component. It renders the parameter component along with additional features.

A class component in React is a JavaScript class that extends the React.Component from the React library. Class components were the primary way of defining components in React before introducing hooks. They encapsulate UI components and their behavior into reusable building blocks.

Class components are defined using ES6 class syntax. And they manage states, handle lifecycle events, and define component methods within the class.

import React, {component} from 'react';
class myComponent extends Component{
  render() {
    return (
      <div>
        <h1>
          Hello, world!
        </h1>
      </div>
    );
  }
}
export default myComponent;

State represents the data the component needs to render and respond to user interactions. You can initialize the state in the constructor using this.state and update it using this.setState.

employeeDetails.jxs
class employeeDetails extends Component{
  constructor(props) {
    super(props);
    this.state = {emp_id: '', emp_email: ''}
  }
  handleInputChange = event => {
    const {name, value} = event.target;
    this.setState({[name]: value});
  };

  render(){
    const { emp_id, emp_email} = this.state;
    return (
      <div className="employee-details">
        <input type="text" name="emp_id" value={emp_id} onChange={
          this.handleInputChange} placeholder="Enter Employee Id" />
        <input type="email" name="emp_email" value={emp_email} onChange={this.handleInputChange} placeholder="Enter Employee Email" />
        <button onClick={ () => alert(`Current Employee Details- ID: ${emp_id}, Email: ${emp_email}`)}Show Details</button>
      </div>
    );
  }
}
export default employeeDetails;

The code defines a class named EmployeeDetails that extends the component class provided by React. In the constructor, the component initializes its state with two properties, emp_id and emp_email, both set to empty strings. This initial state represents the initial values for the input fields where users can enter their employee ID and email.
Play video starting at :3:16 and follow transcript3:16
The component defines a method named handleInputChange to handle changes in the input fields. This method is triggered whenever a change event occurs in the input fields. When the input changes, the method extracts the name and value from the event target input field where the name corresponds to the state property to be updated emp_id or emp_email, and the value corresponds to the new value entered by the user. It then updates the component state by calling this.setState with an object containing the updated property and its new value.

React automatically merges this object with the current state, updating only the specified property while keeping other properties unchanged. The render method delivers the component based on its current state. It dynamically binds the value attribute of the input fields to the corresponding state properties, emp_id and emp_email. This binding ensures the input fields display the current values stored in the component state. When the user interacts with the input fields, the displayed values update in real time as the state changes. When the Show Details button is clicked, an alert is triggered, displaying the current values of emp_id and emp_email. The alert directly accesses the state properties emp_id and emp_email to display their values. Since React manages the state, it ensures that the displayed values are always up to date with the current state.

In React, props or properties send data from parent to child components. The child component receives the data from the parent component and can use it. The props thus received by the child component are read-only and unchangeable. They can also pass methods or functions from parent to child components.

organizationDetails.jxs
import React from 'react'
import employeeDetails from './employeeDetails'

function organizationDetails () {
  let employee_designation = 'Project Manager';
  return (
    <>
      <employeeDetails employee_designation = {employee_designation} />
    </>
  );
}
export default organizationDetails;

Now we can use the employee_designation in the employeeDetails.jxs as follows:

const {employee_designation} = this.props;

Event handling in React is responding to user interactions such as clicks, mouseover, mouse out, form submissions, and so on, within a React application. 

- React is an efficient, flexible JavaScript library for building user interfaces. 

- New features introduced in JavaScript as a part of ES6 are let, const, arrow functions, promise, and class. 

- The main benefits of using JSX are that you can leverage the full power of JavaScript in HTML and avoid learning or using a templating language. It allows React to show useful error and warning messages. 

- The four types of React components are Functional, Class, Pure, and High-order component. 

- Functional components are most useful when the lifecycle of the component doesn’t have to be managed. 

- Class components are more versatile.

Pure component type (4th component type)
In the context of React, a "pure component" typically refers to a component that only re-renders when its props or state change. 

Performance Optimization: By preventing unnecessary re-renders, pure components can improve the performance of your application.
Predictability: Pure components re-render only when their inputs (props or state) change, making their behavior more predictable.

Properties can't be passed as parameters to the function.

Functional components in React receive properties (props) as parameters to the function. These props contain the data passed down from parent components. However, unlike class components, functional components do not have access to the this keyword and cannot use the props property. Instead, they directly accept props as arguments in their function signature.

JSX converts HTML tags into React elements and makes it easier to write React applications.

Lifecycle methods functionality can be added by implementing React Hooks in functional components.

In React, lifecycle methods are special methods that are automatically invoked at specific points in the lifecycle of a component. These methods allow you to hook into various stages of a component's existence, such as when it is initialized, rendered, updated, or removed from the DOM.

The lifecycle of a React component can be divided into three main phases:

- Mounting: This phase occurs when an instance of a component is being created and inserted into the DOM.

constructor(): This method is called before the component is mounted. It is used for initializing state and binding event handlers.

static getDerivedStateFromProps(): This is a static method that is called just before rendering when new props or state are received. It is used to update the state based on changes in props.

render(): This method is required and is responsible for rendering the component's UI.

componentDidMount(): This method is called after the component has been mounted and is rendered for the first time. It is commonly used to perform initial setup, such as fetching data from an API.

- Updating: This phase occurs when a component is re-rendered as a result of changes to its props or state.

static getDerivedStateFromProps(): This method is also called during the updating phase.

shouldComponentUpdate(): This method is called before re-rendering the component. It allows you to control whether the component should update or not based on changes in props or state.

render(): The render method is called again to re-render the component with updated props or state.

getSnapshotBeforeUpdate(): This method is called just before the DOM is updated. It allows you to capture some information from the DOM before it changes, such as scroll position.

componentDidUpdate(): This method is called after the component has been updated and re-rendered. It is commonly used to perform side effects, such as updating the DOM or making additional API calls.

- Unmounting: This phase occurs when a component is removed from the DOM.

componentWillUnmount(): This method is called just before the component is removed from the DOM. It is used to perform cleanup, such as removing event listeners or cancelling network requests.